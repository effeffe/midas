<!DOCTYPE html>
<html lang="en">
<!-- Full ODB editor as pure custom page -->
<!-- Created by Stefan Ritt on July 21st, 2022 -->

<head>
   <meta charset="UTF-8">
   <link rel="stylesheet" href="midas.css" type="text/css">
   <script src="midas.js"></script>
   <script src="mhttpd.js"></script>
   <script src="controls.js"></script>
   <title>MIDAS ODB Browser</title>

   <style>
      #odb .colHeader {
         font-weight: bold;
      }
      #odb .mtable {
         border-spacing: 0;
      }
      #odb td, th {
         padding: 3px;
         user-select: none;
      }
      #odb img {
         cursor: pointer;
         border: 5px solid #E0E0E0;
         border-radius: 5px;
      }
      #odb img:hover {
         border: 5px solid #C8C8C8;
         background-color: #C8C8C8;
      }
   </style>
   <script>

      function getOdbTb(e) {
         while (e !== undefined && e.tagName !== 'TBODY')
            e = e.parentElement;
         return e;
      }

      function odb_init(id, path) {

         if (path === undefined) {
            // get path from URL
            let url = new URL(window.location.href);
            path = url.searchParams.get("odb_path");
            if (path === undefined || path === null || path === "")
               path = '/';
            if (path[0] !== '/')
               path = '/' + path;
         }


         // crate table header
         let d = document.getElementById(id);
         let table = document.createElement('TABLE');
         table.className = "mtable";
         let tb = document.createElement('TBODY');
         table.appendChild(tb);

         // Attach ODB to table body
         tb.odb = {
            id: id,
            updateTimer: 0,
            path: path,
            level: 0,
            dataIndex: 0,
            handleColumn : false,
            detailsColumn: false,
            key: []
         };

         let tr = document.createElement('TR');
         tb.appendChild(tr);
         let th = document.createElement('TH');
         tr.appendChild(th);
         th.className = "mtableheader";
         th.colSpan = "8";
         th.appendChild(document.createTextNode("Online Database Browser"));

         // Dynamic ODB path
         tr = document.createElement('TR');
         tb.appendChild(tr);
         let td = document.createElement('TD');
         td.innerHTML = "";
         td.colSpan = "8";
         tr.appendChild(td);

         tr.addEventListener('click', select_key); // used to deselect any kay

         // Toolbar
         tr = document.createElement('TR');
         tb.appendChild(tr);
         td = document.createElement('TD');
         td.colSpan = "8";
         tr.appendChild(td);
         td.innerHTML =
                 '<img src="icons/file-plus.svg" title="Create key" ' +
                 'onclick="new_key(this)">&nbsp;&nbsp;' +
                 '<img src="icons/folder-plus.svg" title="Create subdirectory" onclick="new_subdir(this)">&nbsp;&nbsp;' +
                 '<img src="icons/link.svg" title="Create link" ' +
                 'onclick="new_link(this)">&nbsp;&nbsp;' +
                 '<img src="icons/edit-3.svg" title="Rename key" ' +
                 'onclick="rename_key(this)">&nbsp;&nbsp;' +
                 '<img src="icons/shuffle.svg" title="Reorder keys" ' +
                 'onclick="toggle_handles(this)">&nbsp;&nbsp;' +
                 '<img src="icons/download.svg" title="Download ODB" ' +
                 'onclick="odb_download(this)">&nbsp;&nbsp;' +
                 '<img src="icons/upload.svg" title="Upload ODB" ' +
                 'onclick="odb_upload(this)">&nbsp;&nbsp;' +
                 '<img src="icons/search.svg" title="Search keys" ' +
                 'onclick="search_key(this)">&nbsp;&nbsp;' +
                 '<img src="icons/trash-2.svg" title="Delete keys" ' +
                 'onclick="odb_delete(this)">&nbsp;&nbsp;' +
                 '<img src="icons/more-vertical.svg" title="More menu commands" ' +
                 'onclick="more_menu(event)">&nbsp;&nbsp;' +
                 '';

         tr.addEventListener('click', select_key); // used to deselect any kay

         // Column header
         tr = document.createElement('TR');
         tb.appendChild(tr);
         let a = [ "Handle", "Key", "Value", "Type", "#Val", "Size", "Written", "Mode" ];
         for (const t of a) {
            td = document.createElement('TD');
            td.className = 'colHeader';
            if (t === "Handle") {
               td.setAttribute('name', 'odbHandle');
               td.style.display = tb.odb.handleColumn ? 'table-cell' : 'none';
               td.style.width = "10px";
            }
            else if (t !== "Key" && t !== "Value") {
               td.innerHTML = t;
               td.setAttribute('name', 'odbExt');
               td.style.display = tb.odb.detailColumn ? 'table-cell' : 'none';
            } else {
               td.innerHTML = t;
            }
            tr.appendChild(td);
         }

         tr.childNodes[2].innerHTML +=
                 "<div title='Show key details' style='display:inline;float:right'>" +
                 "<a id='expRight' href='#' onclick='expand(this);return false;'>&#x21E5;</a>"+
                 "</div>";

         tr.childNodes[7].innerHTML +=
                 "&nbsp;<div title='Hide key details' style='display:inline;float:right'>" +
                 "<a id='expRight' href='#' onclick='expand(this);return false;'>&#x21E4;</a>"+
                 "</div>";

         tr.addEventListener('click', select_key); // used to deselect any kay

         d.appendChild(table);

         odb_update(tb);
      }

      function inline_edit_keydown(event, p) {
         let keyCode = ('which' in event) ? event.which : event.keyCode;

         if (keyCode === 27) {
            // cancel editing
            p.odbParam.inEdit = false;
            p.innerHTML = p.odbParam.oldhtml;
            return false;
         }

         if (keyCode === 13) {
            inline_edit_finish(p);
            return false;
         }

         return true;
      }

      function inline_edit_cancel(event, p) {
         // cancel editing
         if (p.odbParam.inEdit) {
            p.odbParam.inEdit = false;
            p.innerHTML = p.odbParam.oldhtml;
         }
      }

      function inline_edit_finish(p) {
         // finish editing
         let value = p.childNodes[0].value;
         p.odbParam.inEdit = false;
         p.innerHTML = p.odbParam.oldhtml;
         if (p.odbParam.callback)
            p.odbParam.callback(p, value, p.odbParam.param);
      }

      function inline_edit(p, str, callback, size, param) {
         if (p.odbParam !== undefined && p.odbParam.inEdit)
            return;

         p.odbParam = {};
         p.odbParam.param = param;
         p.odbParam.callback = callback;
         p.odbParam.oldhtml = p.innerHTML;
         p.odbParam.inEdit = true;

         if (size === undefined)
         size = str.length;
         if (size === 0)
            size = 10;

         p.innerHTML = "<input type='text' size='" + size + "' value='" + str +
                 "' onKeydown='return inline_edit_keydown(event, this.parentNode);'" +
                 " onBlur='return inline_edit_cancel(event, this.parentNode);'>";

         // needed for Firefox
         setTimeout(function () {
            p.childNodes[0].focus();
            p.childNodes[0].select();
         }, 10);
      }

      function odb_setall(p, value) {
         // console.log(p.odb.param, value);
         let path = p.odbParam.param + '[*]';
         mjsonrpc_db_set_value(path, value);
      }

      function odb_setlink(p, value) {
         // console.log(p.odbParam.param, value);

         dlgAlert("Currently not implemented");

         // mjsonrpc_call("db_link", {"new_links":[p.odb.param],"target_paths":[value]}).then(rpc => {
         // }).catch(error =>{ mjsonrpc_error_alert(error); });
      }

      function new_key(e) {
         let tb = getOdbTb(e);
         document.getElementById('odbCreateDir').innerHTML = tb.odb.path;
         dlgShow('dlgCreate', true);
      }

      function do_new_key() {
         let path = document.getElementById('odbCreateDir').innerHTML;
         if (path === '/') path = "";
         let name = document.getElementById('odbCreateName').value;
         let type = parseInt(document.getElementById('odbCreateType').value);
         let size = parseInt(document.getElementById('odbCreateSize').value);
         let strlen = parseInt(document.getElementById('odbCreateStrLen').value);

         if (name.length < 1) {
            dlgAlert("No name specified");
            return false;
         }

         if (size < 1) {
            dlgAlert("Bad array length: " + size);
            return false;
         }

         if (strlen < 1) {
            dlgAlert("Bad string length " + strlen);
            return false;
         }

         let param = {};
         param.path = path + "/" + name;
         param.type = type;
         if (size > 1)
            param.array_length = size;
         if (strlen > 0)
            param.string_length = strlen;

         mjsonrpc_db_create([param]).then(rpc => {
            let status = rpc.result.status[0];
            if (status === 311) {
               dlgMessage("Error", "ODB entry \"" + name + "\" exists already");
            } else if (status !== 1) {
               dlgMessage("Error", "db_create_key() error " + status + ", see MIDAS messages");
            }
         }).catch(error => mjsonrpc_error_alert(error));

         return true;
      }

      function new_subdir() {
         dlgQuery('Subdirectory name:', "", do_new_subdir);
      }

      function do_new_subdir(subdir) {
         if (subdir === false)
            return;

         if (subdir.length < 1) {
            dlgAlert("No name specified");
            return;
         }

         let path = document.getElementById('odbCreateDir').innerHTML;
         if (path === '/') path = "";
         let param = {};
         param.path = path + "/" + subdir;
         param.type = TID_KEY;

         mjsonrpc_db_create([param]).then(rpc => {
            let status = rpc.result.status[0];
            if (status === 311) {
               dlgMessage("Error", "ODB key \"" + subdir + "\" exists already");
            } else if (status !== 1) {
               dlgMessage("Error", "db_create_key() error " + status + ", see MIDAS messages");
            }
         }).catch(error => mjsonrpc_error_alert(error));
      }

      function new_link() {
         dlgAlert("Function not yet implemented");
      }

      function more_menu(event) {

         event.stopPropagation(); // don't send click to select_key()

         let d = document.getElementById('moreMenu');
         if (d === null) {

            // create menu
            d = document.createElement("div");
            d.id = "moreMenu";
            d.style.display = "none";
            d.style.position = "absolute";
            d.className = "mtable";
            d.style.borderRadius = "0";
            d.style.border = "2px solid #808080";
            d.style.margin = "0";
            d.style.padding = "0";

            d.style.left = "100px";
            d.style.top = "100px";

            let table = document.createElement("table");

            // Show open records ----------

            let tr = document.createElement("tr");
            let td = document.createElement("td");
            td.style.padding = "0";

            let a = document.createElement("a");
            a.href = "" + odb.path;
            a.innerHTML = "Show open record";
            a.title = "Show ODB keys which are open by other programs";
            a.onclick = function () {
               d.style.display = 'none';
               window.location.href = "?cmd=odb_sor&odb_path=" + odb.path;
               return false;
            }
            td.appendChild(a);
            tr.appendChild(td);
            table.appendChild(tr);

            // Show ODB clients  ----------

            tr = document.createElement("tr");
            td = document.createElement("td");
            td.style.padding = "0";

            a = document.createElement("a");
            a.href = "" + odb.path;
            a.innerHTML = "Show ODB clients";
            a.title = "Show clients currently attached to ODB";
            a.onclick = function () {
               d.style.display = 'none';
               window.location.href = "?cmd=odb_scl";
               return false;
            }
            td.appendChild(a);
            tr.appendChild(td);
            table.appendChild(tr);

            d.appendChild(table);

            document.body.appendChild(d);
         }

         let rect = event.target.getBoundingClientRect();

         d.style.display = 'block';
         d.style.left = (rect.left + window.scrollX) + 'px';
         d.style.top = (rect.bottom + 4 + window.scrollY) + 'px';
      }

      function change_color(e, color) {
         if (e.style !== undefined && (e.odb === undefined || !e.odb.inEdit))
            e.style.color = color;
         if (e.childNodes && (e.odb === undefined || !e.odb.inEdit))
            for (const c of e.childNodes)
               change_color(c, color);
      }

      function unselect_all_keys(tb) {
         for (let i=4 ; i<tb.childNodes.length ; i++) {
            let tr = tb.childNodes[i];
            tr.odbSelected = false;
            tr.odbLastSelected = false;
            tr.style.backgroundColor = '';
            change_color(tr, '');
         }
      }

      function select_key(event) {
         event.preventDefault();

         let tr = event.target;
         let tb = getOdbTb(tr);
         let odb = tb.odb;

         // hide submenu if visible
         let m = document.getElementById('moreMenu');
         if (m !== null && m.style.display === 'block')
            m.style.display = 'none';

         // hide context menu if visible
         m = document.getElementById('contextMenu');
         if (m !== null && m.style.display === 'block')
            m.style.display = 'none';

         // don't select key when we are in edit mode
         while (tr.tagName !== 'TR') {
            tr = tr.parentElement;
            if (tr === null)
               return;
         }
         if (find_input_element(tr))
            return;

         // check if click is on header row, if so remove selection further down
         let headerRow = false;
         for (let i=0 ; i<4 ; i++)
            if (tb.childNodes[i] === tr) {
               headerRow = true;
               break;
            }

         if (event.shiftKey && !headerRow) {
            // search last selected row
            let i1;
            for (i1=4 ; i1<tb.childNodes.length ; i1++)
               if (tb.childNodes[i1].odbLastSelected)
                  break;
            if (i1 === tb.childNodes.length)
               i1 = 4; // non selected, so use first one

            let i2;
            for (i2=4 ; i2<tb.childNodes.length ; i2++)
               if (tb.childNodes[i2] === tr)
                  break;

            if (i2 < tb.childNodes.length) {
               if (i1 > i2)
                  [i1, i2] = [i2, i1];

               for (let i=i1 ; i<=i2 ; i++) {
                  // don't select arrays
                  if (tb.childNodes[i].childNodes[1].innerHTML !== "")
                     tb.childNodes[i].odbSelected = true;
               }
            }

         } else if (event.metaKey && !headerRow) {

            // command key just toggles current selection
            tr.odbSelected = !tr.odbSelected;

            for (let i=4 ; i<tb.childNodes.length ; i++)
               tb.childNodes[i].odbLastSelected = false;
            if (tr.odbSelected)
               tr.odbLastSelected = true;

         } else {

            // no key pressed -> un-select all but current
            for (let i=4 ; i<tb.childNodes.length ; i++) {
               tb.childNodes[i].odbSelected = false;
               tb.childNodes[i].odbLastSelected = false;
            }

            // don't select header row and array values
            if (!headerRow && tr.childNodes[1].innerHTML !== "") {
               tr.odbSelected = true;
               tr.odbLastSelected = true;
            }
         }

         // change color of all rows according to selection
         for (let i=4 ; i<tb.childNodes.length ; i++) {
            let tr = tb.childNodes[i];

            tr.style.backgroundColor = tr.odbSelected ? '#004CBD' : '';
            change_color(tr, tr.odbSelected ? '#FFFFFF' : '');
         }
      }

      function context_menu(event) {
         event.preventDefault();
         event.stopPropagation();

         let tr = event.target;
         while (tr.tagName !== 'TR')
            tr = tr.parentElement;
         let tb = getOdbTb(tr);
         let odb = tb.odb;
         let path = tr.odbPath;

         if (!tr.odbSelected)
            select_key(event);

         let d = document.getElementById('contextMenu');
         if (d === null) {

            // create menu
            d = document.createElement("div");
            d.id = "contextMenu";
            d.style.display = "none";
            d.style.position = "absolute";
            d.className = "mtable";
            d.style.borderRadius = "0";
            d.style.border = "2px solid #808080";
            d.style.margin = "0";
            d.style.padding = "0";

            d.style.left = "100px";
            d.style.top = "100px";

            let table = document.createElement("table");

            // delete key ----------

            let trm = document.createElement("tr");
            let tdm = document.createElement("td");
            tdm.style.padding = "0";

            let a = document.createElement("a");
            a.href = "#";
            a.innerHTML = "Delete key";
            a.title = "Delete key";

            tdm.appendChild(a);
            trm.appendChild(tdm);
            table.appendChild(trm);

            // rename key  ----------

            trm = document.createElement("tr");
            tdm = document.createElement("td");
            tdm.style.padding = "0";

            a = document.createElement("a");
            a.href = "#";
            a.innerHTML = "Rename key";
            a.title = "Rename key";

            tdm.appendChild(a);
            trm.appendChild(tdm);
            table.appendChild(trm);

            d.appendChild(table);

            document.body.appendChild(d);
         }

         // set event handler for delete menu
         d.childNodes[0].childNodes[0].childNodes[0].childNodes[0].onclick = function () {
            d.style.display = 'none';
            odb_delete(tr);
         }

         // set event handler for rename menu
         d.childNodes[0].childNodes[1].childNodes[0].childNodes[0].onclick = function () {
            d.style.display = 'none';

            let key = tr.childNodes[1].innerHTML;
            if (key.indexOf('<a href=') !== -1) {
               for (const c of tr.childNodes[1].childNodes)
                  if (c.tagName === 'A') {
                     key = c.innerHTML;
                     break;
                  }
               if (key.indexOf('\u25BE') !== -1)
                  key = key.substring(key.indexOf('\u25BE') + 2);
               if (key.indexOf('\u25B8') !== -1)
                  key = key.substring(key.indexOf('\u25B8') + 2);
            }

            while (key.indexOf("&nbsp;") !== -1)
               key = key.substring(key.indexOf("&nbsp;")+6);

            tr.oldKey = key;

            inline_edit(tr.childNodes[1],
                    key,
                    do_rename_key,
                    key.length,
                    tr.odbPath);
         }

         let rect = event.target.getBoundingClientRect();

         d.style.display = 'block';
         d.style.left = (event.offsetX + rect.left + window.scrollX) + 'px';
         d.style.top = (event.offsetY+rect.top + window.scrollY) + 'px';
      }

      function expand(e) {
         let odb = getOdbTb(e).odb;

         let rarr = document.getElementById('expRight'); // ## TBD
         let n = document.getElementsByName('odbExt');   // ## TBD
         odb.detailsColumn = !odb.detailsColumn;

         if (odb.detailsColumn) {
            for (const d of n)
               d.style.display = 'table-cell';
            rarr.style.display = 'none';
         } else {
            for (const d of n)
               d.style.display = 'none';
            rarr.style.display = 'inline';
         }
      }

      function toggle_handles(e) {
         let odb = getOdbTb(e).odb;

         let n = document.getElementsByName('odbHandle');
         odb.handleColumn = !odb.handleColumn;

         if (odb.handleColumn) {
            for (const d of n)
               d.style.display = 'table-cell';
         } else {
            for (const d of n)
               d.style.display = 'none';
         }
      }

      function odb_delete(e) {
         let tb = getOdbTb(e);
         let paths = [];
         for (const tr of tb.childNodes) {
            if (tr.odbSelected)
               paths.push(tr.odbPath);
         }

         if (paths.length == 0)
            dlgAlert("Please select one or more keys to delete");
         else if (paths.length == 1)
            dlgConfirm('Are you sure to delete odb key ' + paths[0] + '?', do_odb_delete, paths);
         else
            dlgConfirm('Are you sure to delete ' + paths.length + ' keys?', do_odb_delete, paths);
      }

      function do_odb_delete(flag, paths) {
         if (flag)
            mjsonrpc_db_delete(paths).then().catch(error => mjsonrpc_error_alert(error));
      }

      function rename_key_click(event) {
         let tr = event.target;
         while (tr.tagName !== 'TR')
            tr = tr.parentElement;
         if (!tr.odbSelected)
            return;
         if (tr.childNodes[1].odbParam && tr.childNodes[1].odbParam.inEdit)
            return;

         event.stopPropagation(); // don't select key again

         let key = tr.childNodes[1].innerHTML;
         while (key.indexOf("&nbsp;") !== -1)
            key = key.substring(key.indexOf("&nbsp;")+6);

         tr.oldKey = key;

         inline_edit(tr.childNodes[1],
                 key,
                 do_rename_key,
                 key.length,
                 tr.odbPath);
      }

      function rename_key(e) {
         let tb = getOdbTb(e);
         let n = 0;
         let tr;
         for (const t of tb.childNodes) {
            if (t.odbSelected) {
               n++;
               tr = t;
            }
         }

         if (n === 0)
            dlgAlert("Please select key to be renamed");
         else if (n > 1)
            dlgAlert("Please select only single key to be renamed");
         else {
            tr.odbSelected = false;
            tr.style.backgroundColor = '';
            change_color(tr, '');

            let key = tr.childNodes[1].innerHTML;
            if (key.indexOf('<a href=') !== -1) {
               for (const c of tr.childNodes[1].childNodes)
                  if (c.tagName === 'A') {
                     key = c.innerHTML;
                     break;
                  }
               if (key.indexOf('\u25BE') !== -1)
                  key = key.substring(key.indexOf('\u25BE') + 2);
               if (key.indexOf('\u25B8') !== -1)
                  key = key.substring(key.indexOf('\u25B8') + 2);
            }

            while (key.indexOf("&nbsp;") !== -1)
               key = key.substring(key.indexOf("&nbsp;")+6);

            tr.oldKey = key;

            inline_edit(tr.childNodes[1],
                    key,
                    do_rename_key,
                    key.length,
                    tr.odbPath);
         }
      }

      function do_rename_key(p, str, path) {
         if (str === '') {
            dlgAlert("Empty name not allowed");
            return;
         }
         mjsonrpc_call("db_rename", { "paths": [path], "new_names": [str]})
                 .then()
                 .catch(error => mjsonrpc_error_alert(error));
         let old = p.parentElement.oldKey;

         p.innerHTML = p.innerHTML.replace(old, str);
      }

      function search_key() {
         dlgQuery("Enter key name (substring case insensitive):", "", do_search_key);
      }

      function do_search_key(str) {
         if (str !== false)
            window.location.href = "?cmd=Find&value=" + str;
      }

      function odb_download(e) {
         let tb = getOdbTb(e);
         mjsonrpc_db_copy([tb.odb.path]).then(rpc => {

            let dirs = tb.odb.path.split('/');
            let filename = dirs[dirs.length - 1];
            if (filename === '')
               filename = 'root';
            filename += ".json";

            let header = {
               "/MIDAS version": "2.1",
               "/filename": filename,
               "/ODB path": tb.odb.path
            }
            header = JSON.stringify(header);
            header = header.substring(0, header.length-1) + ','; // stip trailing '}'

            let odbJson = JSON.stringify(rpc.result.data[0]);
            if (odbJson.indexOf('{') === 0)
               odbJson = odbJson.substring(1); // strip leading '{'

            odbJson = header + odbJson;

            // use trick from FileSaver.js
            let a = document.getElementById('downloadHook');
            if (a === null) {
               a = document.createElement("a");
               a.style.display = "none";
               a.id = "downloadHook";
               document.body.appendChild(a);
            }

            let blob = new Blob([odbJson], {type: "text/json"});
            let url = window.URL.createObjectURL(blob);

            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);
            dlgAlert("ODB subtree \"" + tb.odb.path +
                    "\" downloaded to file \"" + filename + "\"");

         }).catch(error => mjsonrpc_error_alert(error));
      }

      async function odb_upload(e) {
         dlgShow('dlgFileSelect');
         return;
         // Chrome has file picker, others might have not
         try {
            let fileHandle;
            [fileHandle] = await window.showOpenFilePicker();
            const file = await fileHandle.getFile();
            const text = await file.text();
            pasteBuffer(text);
         } catch (error) {
            if (error.name !== 'AbortError') {
               // fall-back to old method
               dlgShow('fileSelector');
            }
         }
      }

      function loadFileFromSelector() {

         let input = document.getElementById('fileSelector');
         let file = input.files[0];
         if (file !== undefined) {
            let reader = new FileReader();
            reader.readAsText(file);

            reader.onerror = function () {
               dlgAlert('File read error: ' + reader.error);
            };

            reader.onload = function () {
               pasteBuffer(reader.result);
            };
         }
      }

      function pasteBuffer(text) {
         let path = "/Test";
         mjsonrpc_db_paste([path], [text]).then().catch(error =>
         mjsonrpc_error_alert(error));
      }

      // user clicks on subdirectory, so open it
      function subdir_open(e, path) {
         let tb = getOdbTb(e);
         let odb = tb.odb;
         unselect_all_keys(tb);

         // find key belonging to 'path'
         let dirs = path.split('/');
         for (let l=1 ; l<dirs.length ; l++) {
            for (let i = 0 ; i<odb.key.length ; i++)
               if (odb.key[i].name == dirs[l]) {
                  if (l == dirs.length-1)
                     odb.key[i].subdir_open = !odb.key[i].subdir_open;
                  else
                     odb = odb.key[i].value; // recurse one level
                  break;
               }
         }
         odb.skip_yellow = true;
         odb_update(tb);
      }

      // after a double click open the subdirectory as top level
      function subdir_goto(e, path) {
         let tb = getOdbTb(e);
         let odb = tb.odb;

         unselect_all_keys(tb);

         // kill old timer
         if (odb.updateTimer !== undefined)
            window.clearTimeout(odb.updateTimer);

         // update URL
         let url = window.location.href;
         if (url.search("&odb_path") !== -1)
            url = url.slice(0, url.search("&odb_path"));
         url += "&odb_path=" + path;
         if (url !== window.location.href)
            window.history.replaceState({}, "MIDAS ODB Browser", url);

         // update ODB object
         odb.path = path;
         odb.level = 0;
         odb.dataIndex = 0;
         odb.key = [];
         odb.skip_yellow = true;

         odb_update(tb);
      }

      let numClicks = 0;
      let singleClickTimer;
      function subdir_click(event, tr) {

         event.stopPropagation(); // don't pass event to not select row

         // travel from the <a> element up to the <tr> element which contains the path
         while (tr.tagName !== 'TR')
            tr = tr.parentElement;
         let path = tr.odbPath;

         numClicks++;
         if (numClicks === 1) {
            // if no second click in the next 200ms, we have a single click
            singleClickTimer = setTimeout(() => {
               numClicks = 0;
               subdir_open(tr, path);
            }, 200);
         } else if (numClicks === 2) {
            // we have a double click
            clearTimeout(singleClickTimer);
            numClicks = 0;
            subdir_goto(tr, path);
         }
      }

      // push all paths of open subdirectories recursively for a following db_ls
      function push_paths(paths, odb, path) {
         odb.dataIndex = paths.length;
         paths.push(path);
         for (let i=0 ; i< odb.key.length ; i++) {
            if (odb.key[i].type === TID_KEY && odb.key[i].subdir_open) {
               if (odb.key[i].value.id === undefined) {
                  odb.key[i].value = {
                     id: odb.id,
                     path: odb.path === '/' ? '/' + odb.key[i].name : odb.path + '/' + odb.key[i].name,
                     level: odb.level + 1,
                     dataIndex: paths.length,
                     key: []
                  };
               }
               push_paths(paths, odb.key[i].value, odb.key[i].value.path);
            }
         }
      }

      // update overall ODB display
      function odb_update(tb) {
         let odb = tb.odb;

         if (odb.updateTimer !== undefined)
            window.clearTimeout(odb.updateTimer);
         let row = { i:4 };

         // show clickable ODB path in top row
         let dirs;
         if (odb.path === '/')
            dirs = ['/'];
         else
            dirs = odb.path.split('/');
         let path = '';
         let s = "<a href='#' onclick=\"subdir_goto(this, '/');return false;\">/</a>&nbsp;";
         for (let i=1 ; i<dirs.length ; i++) {
            path += "/" + dirs[i];
            s += "<a href='#' onclick=\"subdir_goto(this, '" + path + "');return false;\">"+dirs[i]+"</a>";
            if (i < dirs.length - 1)
               s += "&nbsp;/&nbsp;";
         }
         if (s != tb.childNodes[1].firstChild.innerHTML)
            tb.childNodes[1].firstChild.innerHTML = s;

         // request ODB data
         let paths = [];
         push_paths(paths, odb, odb.path);

         mjsonrpc_db_ls(paths).then(rpc => {
            odb_extract(odb, rpc.result.data);
            odb_print(tb, row, odb);
            odb.skip_yellow = false;

            // call timer in one second to update again
            odb.updateTimer = window.setTimeout(odb_update, 1000, tb);
         }).catch(error => mjsonrpc_error_alert(error));
      }

      // extract keys and put them into odb tree from db_ls result in dataArray
      function odb_extract(odb, dataArray) {
         let data = dataArray[odb.dataIndex];
         let n = 0;
         for (const item in data) {
            if (item.indexOf('/') !== -1)
               continue;

            let key = {};
            key.name = item;
            key.value = data[item];
            if (typeof key.value === 'object' && Object.keys(key.value).length === 0) {
               key.type = TID_KEY;
               key.subdir_open = false;
               key.num_values = 1;
               key.item_size = 0;
               key.last_written = 0;
               key.access_mode = 0;
            } else {
               key.type = data[item + '/key'].type;
               key.link = data[item + '/key'].link;
               key.num_values = data[item + '/key'].num_values;
               if (key.num_values === undefined)
                  key.num_values = 1;
               if (data[item + '/key'].item_size !== undefined)
                  key.item_size = data[item + '/key'].item_size;
               else
                  key.item_size = tid_size[key.type];
               key.last_written = data[item + '/key'].last_written;
               key.access_mode = data[item + '/key'].access_mode;
            }

            if (odb.key.length <= n)
               odb.key.push(key);
            else {
               if (odb.key[n].subdir_open) {
                  key.subdir_open = true;
                  key.value = odb.key[n].value;
               }
               odb.key[n] = key;
            }
            n++;

            // if current key is a subdirectory, call us recursively
            if (key.type === TID_KEY && key.subdir_open) {
               odb_extract(odb.key[n-1].value, dataArray);
            }
         }

         // if local data remaining, ODB key must have been deleted, so delete also local data
         if (odb.key.length > n) {
            odb.key = odb.key.slice(0, n);
            odb.skip_yellow = true;
         }
      }

      function odb_print(tb, row, odb) {
         for (const key of odb.key) {
            // Print current key
            odb_print_key(tb, row, odb.path, key, odb.level);
            row.i++;

            // Print whole subdirectory if open
            if (key.type === TID_KEY && key.subdir_open) {

               // Propagate skip_yellow flag (dirctory just opened) to all subkeys
               key.value.skip_yellow = odb.skip_yellow;

               // Print whole subdirectory
               odb_print(tb, row, key.value);
            }
         }

         // At the end, remove old rows if subdirectory has been closed
         if (odb.level === 0)
            while (tb.childNodes.length > row.i)
               tb.removeChild(tb.childNodes[tb.childNodes.length-1]);
      }

      function find_input_element(e) {
         if (e === undefined)
            return false;
         for (const c of e.childNodes) {
            if (c.tagName === 'INPUT')
               return true;
            if (c.childNodes.length > 0)
               if (find_input_element(c))
                  return true;
         }
         return false;
      }

      function odb_print_key(tb, row, path, key, level) {
         let odb = tb.odb;

         // console.log(row, key.name, key.value);

         // ful path to key
         let keyPath = (path === '/' ? '/' + key.name : path + '/' + key.name);

         // create empty row
         let tr = document.createElement('TR');

         // Handle column
         let td = document.createElement('TD');
         td.className = 'odbKey';
         td.setAttribute('name', 'odbHandle');
         td.style.display = odb.handleColumn ? 'table-cell' : 'none';
         td.style.width = "10px";
         tr.appendChild(td);
         td.innerHTML = '<img src="icons/menu.svg">';

         // Key name
         td = document.createElement('TD');
         td.className = 'odbKey';
         tr.appendChild(td);

         // Add three spaces of indent for each level
         let indent = "";
         for (let i = 0; i < level; i++)
            indent += "&nbsp;&nbsp;&nbsp;";

         // Remember indent level for key rename
         tr.level = odb.level;

         // Print subdir with open subdir handler
         if (key.type === TID_KEY) {
            let handler = "onclick=\"subdir_click(event, this);return false;\" ";
            if (key.subdir_open)
               td.innerHTML = indent + "<a href='#' " +
                       handler +
                       "> \u25BE " + key.name + "</a>";
            else
               td.innerHTML = indent + "<a href='#' " +
                       handler +
                       "> \u25B8 " + key.name + "</a>";
         } else {
            td.innerHTML = indent + key.name;
            td.addEventListener('click', rename_key_click);
         }

         // add link if present
         if (key.link !== undefined) {
            td.innerHTML += ' &rarr; <span>'+ '<a href="#" ' +
                    'onclick="inline_edit(this.parentNode, \'' +
                    key.link + '\', odb_setlink, undefined, \'' + keyPath +
                    '\'); return false;" ' +
                    ' title="Change value">' + key.link +
                    '</a></span>';
         }

         // Subdirs occupy all 8 columns
         if (key.type === TID_KEY) {
            td.colSpan = "8";

            if (tb.childNodes.length > row.i) {
               let selected = tb.childNodes[row.i].odbSelected;
               if (selected) {
                  tr.style.backgroundColor = '#004CBD';
                  change_color(tr, '#FFFFFF');
               }

               if (!tb.childNodes[row.i].isEqualNode(tr)) {
                  // check for edit mode
                  let inlineEdit = find_input_element(tb.childNodes[row.i]);
                  if (!inlineEdit)
                     tb.childNodes[row.i].replaceWith(tr);
               }
            } else
               tb.appendChild(tr);

            // Install mouse click handler
            tb.childNodes[row.i].addEventListener('click', select_key);
            tb.childNodes[row.i].addEventListener('contextmenu', context_menu);

            // Remember ODB path in row
            tb.childNodes[row.i].odbPath = keyPath;

            return;
         }

         // Value
         td = document.createElement('TD');
         td.className = 'odbKey';
         tr.appendChild(td);

         if (Array.isArray(key.value)) {
            if (key.value.length > 4096)
               td.innerHTML = '... ' + key.value.length + ' values ...';
            else
               td.innerHTML =
                    '<div><a href="#" ' +
                    'onclick="inline_edit(this.parentNode, \'' +
                    key.value[0] + '\', odb_setall, 10, \''+ keyPath +
                    '\');return false;" ' +
                    'title="Set array elements to same value">*</a></div>';
         } else {
            let edit = '<a href="#" onclick="ODBInlineEdit(this.parentNode, \'' + keyPath + '\');return false;" ' +
                    'onfocus="ODBInlineEdit(this.parentNode, \'' + keyPath + '\')" title="Change value">';

            let v = key.value.toString();
            if (key.type === TID_STRING && v === "")
               v = "(empty)";
            else if (key.type === TID_LINK)
               v = '<span style="color:red;background-color:yellow">(cannot resolve link)</span>';
            else if (key.type === TID_BOOL)
               v = (key.value ? 'y' : 'n') + ' (' + (key.value ? '1' : '0') + ')';
            else if (v.substring(0, 2) === "0x")
               v += " (" + parseInt(key.value) + ')';
            else if (key.type !== TID_STRING && key.type !== TID_LINK && key.type !== TID_FLOAT && key.type !== TID_DOUBLE)
               v += " (0x" + key.value.toString(16).toUpperCase() + ')';
            td.innerHTML = edit + v + '</a>';
         }

         // Type
         td = document.createElement('TD');
         td.className = 'odbKey';
         td.setAttribute('name', 'odbExt');
         td.style.display = odb.detailsColumn ? 'table-cell' : 'none';
         tr.appendChild(td);
         td.appendChild(document.createTextNode(tid_name[key.type]));

         // #Val
         td = document.createElement('TD');
         td.className = 'odbKey';
         td.setAttribute('name', 'odbExt');
         td.style.display = odb.detailsColumn ? 'table-cell' : 'none';
         tr.appendChild(td);
         td.innerHTML = '<a href="#" onclick="resize_array(event, \''+keyPath+'\','+key.num_values+');return false;">'
                 + key.num_values + '</a>';

         // Size
         td = document.createElement('TD');
         td.className = 'odbKey';
         td.setAttribute('name', 'odbExt');
         td.style.display = odb.detailsColumn ? 'table-cell' : 'none';
         tr.appendChild(td);
         if (key.type === TID_STRING)
            td.innerHTML = '<a href="#" onclick="resize_string(event, \''+keyPath+'\','+key.item_size+','+key.num_values+');return false;">'
                    + key.item_size + '</a>';
         else
            td.innerHTML = key.item_size;

         // Written
         td = document.createElement('TD');
         td.className = 'odbKey';
         td.setAttribute('name', 'odbExt');
         td.style.display = odb.detailsColumn ? 'table-cell' : 'none';
         tr.appendChild(td);
         let s = Math.floor(0.5 + new Date().getTime() / 1000 - key.last_written);
         let t;
         if (s < 60)
            t = s + 's';
         else if (s < 60 * 60)
            t = Math.floor(0.5 + s / 60) + 'm';
         else if (s < 60 * 60 * 24)
            t = Math.floor(0.5 + s / 60 / 60) + 'h';
         else if (s < 60 * 60 * 24 * 99)
            t = Math.floor(0.5 + s / 60 / 60 / 24) + 'd';
         else
            t = ">99d";
         td.appendChild(document.createTextNode(t));

         // Mode
         td = document.createElement('TD');
         td.className = 'odbKey';
         td.setAttribute('name', 'odbExt');
         td.style.display = odb.detailsColumn ? 'table-cell' : 'none';
         tr.appendChild(td);
         let mode = key.access_mode;
         let m = "";
         if (mode & MODE_READ)
            m += "R";
         if (mode & MODE_WRITE)
            m += "W";
         if (mode & MODE_DELETE)
            m += "D";
         if (mode & MODE_EXCLUSIVE)
            m += "X";
         if (mode & MODE_WATCH)
            m += "W";
         td.appendChild(document.createTextNode(m));

         if (row.i >= tb.childNodes.length) {
            // append new row if nothing exists
            tb.appendChild(tr);
         } else {
            // replace current row if it differs
            if (!tb.childNodes[row.i].isEqualNode(tr)) {
               if (tb.childNodes[row.i].childNodes[1].colSpan !== 1)
                  tb.childNodes[row.i].childNodes[1].colSpan = "1";
               for (let i = 0; i < 8; i++) {
                  let yellowBg = false;

                  // check for data change in value column
                  if (i === 2) {
                     let oldElem = tb.childNodes[row.i].childNodes[i];
                     if (oldElem === undefined)
                        oldElem = "";
                     else {
                        while (oldElem.tagName === 'TD' || oldElem.tagName === 'A' || oldElem.tagName === 'DIV')
                           oldElem = oldElem.childNodes[0]; // get into <td> <a> <div> elements
                        oldElem = oldElem.parentNode.innerHTML;
                     }
                     let newElem = tr.childNodes[i];
                     if (newElem === undefined)
                        newElem = "";
                     else {
                        while (newElem.tagName === 'TD' || newElem.tagName === 'A' || newElem.tagName === 'DIV')
                           newElem = newElem.childNodes[0]; // get into <td> <a> <div> elements
                        newElem = newElem.parentNode.innerHTML;
                     }

                     if (oldElem !== newElem &&  // value changed
                             !odb.skip_yellow &&       // skip if globally disabled
                             // skip if edit just finished
                             !(oldElem.indexOf('(') == -1 && newElem.indexOf('(') !== -1) &&
                             // skip '*' of arrays
                             newElem.indexOf('>*</a>') === -1)
                        yellowBg = true;
                     else
                        yellowBg = false;
                  }

                  // check for edit mode
                  let inlineEdit = find_input_element(tb.childNodes[row.i].childNodes[i]);

                  if (tb.childNodes[row.i].childNodes[i] === undefined)
                     tb.childNodes[row.i].appendChild(tr.childNodes[i].cloneNode(true));
                  else if (!inlineEdit) {
                     let e = tb.childNodes[row.i].childNodes[i];

                     let c = e.style.color; // preserve color if key is selected
                     e.innerHTML = tr.childNodes[i].innerHTML;
                     change_color(e, c);

                     if (i == 1 && key.type !== TID_KEY)
                        e.addEventListener('click', rename_key_click);

                     if (yellowBg) {
                        e.style.backgroundColor = 'var(--myellow)';
                        e.style.setProperty("-webkit-transition", "", "");
                        e.style.setProperty("transition", "", "");
                        e.age = new Date() / 1000;
                     }

                     if (e.age !== undefined && new Date() / 1000 > e.age + 1) {
                        e.style.setProperty("-webkit-transition", "background-color 1s", "");
                        e.style.setProperty("transition", "background-color 1s", "");
                        e.style.backgroundColor = "";
                     }
                  }
               }
            }
         }

         // Install mouse click handler
         tb.childNodes[row.i].addEventListener('click', select_key);
         tb.childNodes[row.i].addEventListener('contextmenu', context_menu);

         // Remember ODB path in row
         tb.childNodes[row.i].odbPath = keyPath;

         // Print array values
         if (Array.isArray(key.value)) {
            if (key.value.length > 4096) {
               // do nothing
            } else for (let i=0 ; i<key.value.length ; i++) {
               row.i++;

               // return if in edit mode
               if (tb.childNodes[row.i] !== undefined &&
                       tb.childNodes[row.i].childNodes[2] !== undefined &&
                       tb.childNodes[row.i].childNodes[2].inEdit)
                  continue;

               // create empty row
               let tr = document.createElement('TR');

               // Handle column (empty for array values)
               let td = document.createElement('TD');
               td.className = 'odbKey';
               td.setAttribute('name', 'odbHandle');
               td.style.display = odb.handleColumn ? 'table-cell' : 'none';
               td.style.width = "10px";
               tr.appendChild(td);

               // Key name
               td = document.createElement('TD');
               td.className = 'odbKey';
               tr.appendChild(td);

               // Key value
               td = document.createElement('TD');
               td.className = 'odbKey';
               tr.appendChild(td);
               let p = (path === '/' ? '/' + key.name : path + '/' + key.name);
               p += '['+i+']';
               let edit = '<a href="#" onclick="ODBInlineEdit(this.parentNode, \''+p+'\');return false;"  '+
                       'onfocus="ODBInlineEdit(this.parentNode, \''+p+'\')" title="Change array element">';

               let v = key.value[i].toString();
               if (key.type === TID_STRING && v === "")
                  v = "(empty)";
               else if (key.type === TID_BOOL)
                  v = (key.value[i] ? 'y' : 'n') + ' (' + (key.value[i] ? '1' : '0') +')';
               else if (v.substring(0, 2) === "0x")
                  v += " (" + parseInt(key.value[i]) + ')';
               else if (key.type !== TID_STRING && key.type !== TID_LINK && key.type !== TID_FLOAT && key.type !== TID_DOUBLE)
                  v += " (0x" + key.value[i].toString(16).toUpperCase() + ')';
               td.innerHTML = '['+i+'] '+ edit + v + '</a>';

               // Empty fill cells
               for (let i=0 ; i<5 ; i++) {
                  td = document.createElement('TD');
                  td.className = 'odbKey';
                  td.setAttribute('name', 'odbExt');
                  td.style.display = odb.detailsColumn ? 'table-cell' : 'none';
                  tr.appendChild(td);
               }

               if (row.i >= tb.childNodes.length) {
                  tb.appendChild(tr);
               } else {
                  if (!tb.childNodes[row.i].isEqualNode(tr)) {
                     if (tr.childNodes.length === 1) { // Subdir
                        tb.childNodes[row.i].replaceWith(tr);
                     } else if (tr.childNodes.length === 8) { // Key
                        if (tb.childNodes[row.i].childNodes[1].colSpan !== 1)
                           tb.childNodes[row.i].childNodes[1].colSpan = "1";
                        for (let i = 0; i < 8; i++) {
                           let changed = false;

                           let oldValue;
                           if (tb.childNodes[row.i].childNodes[i] !== undefined)
                              oldValue = tb.childNodes[row.i].childNodes[i].innerHTML;
                           let newValue = tr.childNodes[i].innerHTML;

                           if (oldValue !== undefined &&
                                   oldValue !== newValue &&  // value changed
                                   i === 2 &&                // we are in value column
                                   !odb.skip_yellow &&       // skip if globally disabled
                                   // skip if edit just finished
                                   !(oldValue.indexOf('(') == -1 && newValue.indexOf('(') !== -1) &&
                                   // skip '*' of arrays
                                   newValue.indexOf('>*</a>') === -1)
                              changed = true;

                           if (tb.childNodes[row.i].childNodes[i] === undefined)
                              tb.childNodes[row.i].appendChild(tr.childNodes[i].cloneNode(true));
                           else
                              tb.childNodes[row.i].childNodes[i].innerHTML = tr.childNodes[i].innerHTML;

                           let e = tb.childNodes[row.i].childNodes[i];
                           if (changed) {
                              e.style.backgroundColor = 'var(--myellow)';
                              e.style.setProperty("-webkit-transition", "", "");
                              e.style.setProperty("transition", "", "");
                              e.age = new Date() / 1000;
                           }

                           if (e.age !== undefined && new Date() / 1000 > e.age + 1) {
                              e.style.setProperty("-webkit-transition", "background-color 1s", "");
                              e.style.setProperty("transition", "background-color 1s", "");
                              e.style.backgroundColor = "";
                           }
                        }
                     }
                  }
               }
            }
         }
      }

      function resize_array(event, path, n) {
         event.stopPropagation(); // do not select row
         dlgQuery("Enter size of array:", n, do_resize_array, path);
      }

      function do_resize_array(n, path) {
         mjsonrpc_db_resize([path],[parseInt(n)]).then(rpc => {
         }).catch(error => mjsonrpc_error_alert(error));
      }

      function resize_string(event, path, size, num_values) {
         event.stopPropagation(); // do not select row
         dlgQuery("Enter new string size:", size, do_resize_string, { "path": path, "num_values": num_values });
      }

      function do_resize_string(size, p) {
         mjsonrpc_call("db_resize_string",
                 { "paths": [p.path],
                    "new_lengths": [parseInt(p.num_values)],
                    "new_string_lengths": [parseInt(size)]}).then(rpc => {
         }).catch(error => mjsonrpc_error_alert(error));
      }

   </script>
</head>

<body class="mcss" onload="mhttpd_init('ODB'); odb_init('odb')">

   <div id="mheader"></div>
   <div id="msidenav"></div>

   <div id="mmain">
      <div id="odb"></div>
   </div>

   <!-- Create key dialog -->
   <div id="dlgCreate" class="dlgFrame">
      <div class="dlgTitlebar">Create ODB entry</div>
      <div class="dlgPanel">
         <table class="dialogTable" style="border-spacing:10px;">
            <tr>
               <td style="text-align: right">Directory:</td>
               <td style="text-align: left" id="odbCreateDir"></td>
            </tr>
            <tr>
               <td style="text-align: right">Type:</td>
               <td style="text-align: left">
                  <select id="odbCreateType"
                          onchange="
                             document.getElementById('odbCreateStrLenTR').style.visibility =
                                (this.value==='12') ? 'visible' : 'hidden';
                          ">
                     <option selected value=7>Integer (32-bit)
                     <option value=9>Float (4 Bytes)
                     <option value=12>String
                     <option value=1>Byte
                     <option value=2>Signed Byte
                     <option value=3>Character (8-bit)
                     <option value=4>Word (16-bit)
                     <option value=5>Short Integer (16-bit)
                     <option value=6>Double Word (32-bit)
                     <option value=8>Boolean
                     <option value=10>Double Float (8 Bytes)
                  </select>
               </td>
            </tr>
            <tr>
               <td style="text-align: right">Name:</td>
               <td style="text-align: left"><input type=text size=20 maxlength=31 id="odbCreateName"></td>
            </tr>
            <tr>
               <td style="text-align: right">Array size:</td>
               <td style="text-align: left"><input type=text size=6 value=1 id="odbCreateSize"></td>
            </tr>
            <tr id="odbCreateStrLenTR" style="visibility: hidden">
               <td style="text-align: right">String length:</td>
               <td style="text-align: left"><input type=text size=6 value=32 id="odbCreateStrLen"></td>
            </tr>
         </table>
         <button class="dlgButton" onclick="if(do_new_key(this))dlgHide('dlgCreate');">Create</button>
         <button class="dlgButton" onclick="dlgHide('dlgCreate')">Cancel</button>
      </div>
   </div>

   <!-- Select file dialog -->
   <div id="dlgFileSelect" class="dlgFrame">
      <div class="dlgTitlebar">Select file</div>
      <div class="dlgPanel">
         </br><div style="margin: auto;width:70%">
         <input type="file" id="fileSelector" accept=".json"></div></br></br>
         <button class="dlgButton" onclick="loadFileFromSelector();dlgHide('dlgFileSelect');">Upload</button>
         <button class="dlgButton" onclick="dlgHide('dlgFileSelect')">Cancel</button>
      </div>
   </div>

</body>
</html>
