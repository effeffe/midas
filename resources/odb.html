<!DOCTYPE html>
<html lang="en">
<!-- Full ODB editor as pure custom page -->
<!-- Created by Stefan Ritt on July 21st, 2022 -->

<head>
   <meta charset="UTF-8">
   <link rel="stylesheet" href="midas.css" type="text/css">
   <script src="midas.js"></script>
   <script src="mhttpd.js"></script>
   <script src="controls.js"></script>
   <title>MIDAS ODB Browser</title>

   <style>
      #odb .colHeader {
         font-weight: bold;
      }
      #odb .mtable {
         border-spacing: 0;
      }
      #odb td, th {
         padding: 3px;
         user-select: none;
      }
      #odb img {
         cursor: pointer;
         border: 5px solid #E0E0E0;
         border-radius: 5px;
      }
      #odb img:hover {
         border: 5px solid #C8C8C8;
         background-color: #C8C8C8;
      }
   </style>
   <script>

      let odb = {};

      function odb_init(id, path) {

         if (path === undefined) {
            // get path from URL
            let url = new URL(window.location.href);
            path = url.searchParams.get("odb_path");
            if (path === undefined || path === null || path === "")
               path = '/';
            if (path[0] !== '/')
               path = '/' + path;
         }

         // initialize ODB object
         odb = { id: id, path: path, level: 0, dataIndex: 0, key: [] };

         // crate table header
         let d = document.getElementById(id);
         let table = document.createElement('TABLE');
         table.className = "mtable";
         let tb = document.createElement('TBODY');
         table.appendChild(tb);
         let tr = document.createElement('TR');
         tb.appendChild(tr);
         let th = document.createElement('TH');
         tr.appendChild(th);
         th.className = "mtableheader";
         th.colSpan = "8";
         th.appendChild(document.createTextNode("Online Database Browser"));

         // Dynamic ODB path
         tr = document.createElement('TR');
         tb.appendChild(tr);
         let td = document.createElement('TD');
         td.innerHTML = "";
         td.colSpan = "8";
         tr.appendChild(td);

         tr.addEventListener('click', select_key); // used to deselect any kay

         // Toolbar
         tr = document.createElement('TR');
         tb.appendChild(tr);
         td = document.createElement('TD');
         td.colSpan = "8";
         tr.appendChild(td);
         td.innerHTML =
                 '<img src="icons/file-plus.svg" title="Create key" ' +
                 'onclick="new_key()">&nbsp;&nbsp;' +
                 '<img src="icons/folder-plus.svg" title="Create subdirectory" onclick="new_subdir()">&nbsp;&nbsp;' +
                 '<img src="icons/link.svg" title="Create link" ' +
                 'onclick="new_link()">&nbsp;&nbsp;' +
                 '<img src="icons/edit-3.svg" title="Rename key" ' +
                 'onclick="rename_key()">&nbsp;&nbsp;' +
                 '<img src="icons/shuffle.svg" title="Reorder keys" ' +
                 'onclick="toggle_handles()">&nbsp;&nbsp;' +
                 '<img src="icons/search.svg" title="Search keys" ' +
                 'onclick="search_key()">&nbsp;&nbsp;' +
                 '<img src="icons/trash-2.svg" title="Delete keys" ' +
                 'onclick="odb_delete()">&nbsp;&nbsp;' +
                 '<img src="icons/more-vertical.svg" title="More menu commands" ' +
                 'onclick="more_menu()">&nbsp;&nbsp;' +
                 '';

         tr.addEventListener('click', select_key); // used to deselect any kay

         // Column header
         tr = document.createElement('TR');
         tb.appendChild(tr);
         let a = [ "Handle", "Key", "Value", "Type", "#Val", "Size", "Written", "Mode" ];
         for (const t of a) {
            td = document.createElement('TD');
            td.className = 'colHeader';
            if (t === "Handle") {
               td.setAttribute('name', 'odbHandle');
               td.style.display = odbHandle ? 'table-cell' : 'none';
               td.style.width = "10px";
            }
            else if (t !== "Key" && t !== "Value") {
               td.innerHTML = t;
               td.setAttribute('name', 'odbExt');
               td.style.display = odbExpand ? 'table-cell' : 'none';
            } else {
               td.innerHTML = t;
            }
            tr.appendChild(td);
         }

         tr.childNodes[2].innerHTML +=
                 "<div title='Show key details' style='display:inline;float:right'>" +
                 "<a id='expRight' href='#' onclick='expand();return false;'>&#x21E5;</a>"+
                 "</div>";

         tr.childNodes[7].innerHTML +=
                 "&nbsp;<div title='Hide key details' style='display:inline;float:right'>" +
                 "<a id='expRight' href='#' onclick='expand();return false;'>&#x21E4;</a>"+
                 "</div>";

         tr.addEventListener('click', select_key); // used to deselect any kay

         d.appendChild(table);

         odb_update(odb);
      }

      function inline_edit_keydown(event, p) {
         let keyCode = ('which' in event) ? event.which : event.keyCode;

         if (keyCode === 27) {
            // cancel editing
            p.odb.inEdit = false;
            p.innerHTML = p.odb.oldhtml;
            if (p.inRename)
               p.inRename = false;
            return false;
         }

         if (keyCode === 13) {
            inline_edit_finish(p);
            return false;
         }

         return true;
      }

      function inline_edit_finish(p) {
         // finish editing
         if (!p.odb.inEdit)
            return;
         let value = p.childNodes[0].value;
         p.odb.inEdit = false;
         p.innerHTML = p.odb.oldhtml;
         if (p.odb.callback)
            p.odb.callback(p, value, p.odb.param);
      }

      function inline_edit(p, str, callback, size, param) {
         if (p.odb == undefined) {
            p.odb = {
               "inEdit": false,
               "param": param,
               "callback": callback,
               "oldhtml": p.innerHTML
            };
         }
         if (p.odb.inEdit)
            return;
         p.odb.inEdit = true;

         if (size === undefined)
         size = str.length;
         if (size === 0)
            size = 10;

         p.innerHTML = "<input type='text' size='" + size + "' value='" + str +
                 "' onKeydown='return inline_edit_keydown(event, this.parentNode);' onBlur='inline_edit_finish(this.parentNode);' >";

         // needed for Firefox
         setTimeout(function () {
            p.childNodes[0].focus();
            p.childNodes[0].select();
         }, 10);
      }

      function odb_setall(p, value) {
         // console.log(p.odb.param, value);
         let path = p.odb.param + '[*]';
         mjsonrpc_db_set_value(path, value);
      }

      function odb_setlink(p, value) {
         // console.log(p.odb.param, value);

         dlgAlert("Currently not implemented");

         // mjsonrpc_call("db_link", {"new_links":[p.odb.param],"target_paths":[value]}).then(rpc => {
         // }).catch(error =>{ mjsonrpc_error_alert(error); });
      }

      function new_key() {
         document.getElementById('odbCreateDir').innerHTML = odb.path;
         dlgShow('dlgCreate', true);
      }

      function do_new_key() {
         let path = odb.path;
         if (path === '/') path = "";
         let name = document.getElementById('odbCreateName').value;
         let type = parseInt(document.getElementById('odbCreateType').value);
         let size = parseInt(document.getElementById('odbCreateSize').value);
         let strlen = parseInt(document.getElementById('odbCreateStrLen').value);

         if (name.length < 1) {
            dlgAlert("No name specified");
            return false;
         }

         if (size < 1) {
            dlgAlert("Bad array length: " + size);
            return false;
         }

         if (strlen < 1) {
            dlgAlert("Bad string length " + strlen);
            return false;
         }

         let param = {};
         param.path = path + "/" + name;
         param.type = type;
         if (size > 1)
            param.array_length = size;
         if (strlen > 0)
            param.string_length = strlen;

         mjsonrpc_db_create([param]).then(rpc => {
            let status = rpc.result.status[0];
            if (status === 311) {
               dlgMessage("Error", "ODB entry \"" + name + "\" exists already");
            } else if (status !== 1) {
               dlgMessage("Error", "db_create_key() error " + status + ", see MIDAS messages");
            }
         }).catch(error => mjsonrpc_error_alert(error));

         return true;
      }

      function new_subdir() {
         dlgQuery('Subdirectory name:', "", do_new_subdir);
      }

      function do_new_subdir(subdir) {
         if (subdir === false)
            return;

         if (subdir.length < 1) {
            dlgAlert("No name specified");
            return;
         }

         let path = odb.path;
         if (path === '/') path = "";
         let param = {};
         param.path = path + "/" + subdir;
         param.type = TID_KEY;

         mjsonrpc_db_create([param]).then(rpc => {
            let status = rpc.result.status[0];
            if (status === 311) {
               dlgMessage("Error", "ODB key \"" + subdir + "\" exists already");
            } else if (status !== 1) {
               dlgMessage("Error", "db_create_key() error " + status + ", see MIDAS messages");
            }
         }).catch(error => mjsonrpc_error_alert(error));
      }

      function new_link() {
         dlgAlert("Function not yet implemented");
      }

      function more_menu() {
         dlgAlert("Function not yet implemented");
      }

      function change_color(e, color) {
         if (e.style !== undefined && !e.inRename)
            e.style.color = color;
         if (e.childNodes && !e.inRename)
            for (const c of e.childNodes)
               change_color(c, color);
      }

      function unselect_all_keys() {
         let tb = document.getElementById(odb.id).firstChild.firstChild;
         for (let i=4 ; i<tb.childNodes.length ; i++) {
            let tr = tb.childNodes[i];
            tr.odbSelected = false;
            tr.odbLastSelected = false;
            tr.style.backgroundColor = '';
            change_color(tr, '');
         }
      }

      function select_key(event) {
         event.preventDefault();

         let tb = document.getElementById(odb.id).firstChild.firstChild;
         let tr = event.target;

         // don't select key when we are in edit mode
         if (tr.tagName === 'INPUT')
            return;
         while (tr.tagName !== 'TR') {
            tr = tr.parentElement;
            if (tr === null)
               return;
         }

         // check if click is on header row, if so remove selection further down
         let headerRow = false;
         for (let i=0 ; i<4 ; i++)
            if (tb.childNodes[i] === tr) {
               headerRow = true;
               break;
            }

         if (event.shiftKey && !headerRow) {
            // search last selected row
            let i1;
            for (i1=4 ; i1<tb.childNodes.length ; i1++)
               if (tb.childNodes[i1].odbLastSelected)
                  break;
            if (i1 === tb.childNodes.length)
               i1 = 4; // non selected, so use first one

            let i2;
            for (i2=4 ; i2<tb.childNodes.length ; i2++)
               if (tb.childNodes[i2] === tr)
                  break;

            if (i2 < tb.childNodes.length) {
               if (i1 > i2)
                  [i1, i2] = [i2, i1];

               for (let i=i1 ; i<=i2 ; i++) {
                  // don't select arrays
                  if (tb.childNodes[i].childNodes[1].innerHTML !== "")
                     tb.childNodes[i].odbSelected = true;
               }
            }

         } else if (event.metaKey && !headerRow) {

            // command key just toggles current selection
            tr.odbSelected = !tr.odbSelected;

            for (let i=4 ; i<tb.childNodes.length ; i++)
               tb.childNodes[i].odbLastSelected = false;
            if (tr.odbSelected)
               tr.odbLastSelected = true;

         } else {

            // no key pressed -> un-select all but current
            for (let i=4 ; i<tb.childNodes.length ; i++) {
               tb.childNodes[i].odbSelected = false;
               tb.childNodes[i].odbLastSelected = false;
            }

            if (!headerRow) {
               tr.odbSelected = true;
               tr.odbLastSelected = true;
            }
         }

         // change color of all rows according to selection
         for (let i=4 ; i<tb.childNodes.length ; i++) {
            let tr = tb.childNodes[i];

            tr.style.backgroundColor = tr.odbSelected ? '#004CBD' : '';
            change_color(tr, tr.odbSelected ? '#FFFFFF' : '');
         }
      }

      let odbExpand = false;
      let odbHandle = false;
      let updateTimer;

      function expand() {
         let rarr = document.getElementById('expRight');
         let n = document.getElementsByName('odbExt');
         odbExpand = !odbExpand;

         if (odbExpand) {
            for (const d of n)
               d.style.display = 'table-cell';
            rarr.style.display = 'none';
         } else {
            for (const d of n)
               d.style.display = 'none';
            rarr.style.display = 'inline';
         }
      }

      function toggle_handles() {
         let n = document.getElementsByName('odbHandle');
         odbHandle = !odbHandle;

         if (odbHandle) {
            for (const d of n)
               d.style.display = 'table-cell';
         } else {
            for (const d of n)
               d.style.display = 'none';
         }
      }

      function odb_delete() {
         let d = document.getElementById(odb.id);
         let tb = d.firstChild.firstChild;
         let paths = [];
         for (const tr of tb.childNodes) {
            if (tr.odbSelected)
               paths.push(tr.odbPath);
         }

         if (paths.length == 0)
            dlgAlert("Please select one or more keys to delete");
         else if (paths.length == 1)
            dlgConfirm('Are you sure to delete odb key ' + paths[0] + '?', do_odb_delete, paths);
         else
            dlgConfirm('Are you sure to delete ' + paths.length + ' keys?', do_odb_delete, paths);
      }

      function do_odb_delete(flag, paths) {
         if (flag)
            mjsonrpc_db_delete(paths).then().catch(error => mjsonrpc_error_alert(error));
      }

      function rename_key() {
         let d = document.getElementById(odb.id);
         let tb = d.firstChild.firstChild;
         let n = 0;
         let tr;
         for (const t of tb.childNodes) {
            if (t.odbSelected) {
               n++;
               tr = t;
            }
         }

         if (n === 0)
            dlgAlert("Please select key to be renamed");
         else if (n > 1)
            dlgAlert("Please select only single key to be renamed");
         else {
            tr.inRename = true;
            inline_edit(tr.childNodes[1],
                    tr.childNodes[1].innerHTML,
                    do_rename_key,
                    tr.childNodes[1].innerHTML.length,
                    tr.odbPath);
         }
      }

      function do_rename_key(p, str, path) {
         p.parentNode.inRename = false;
         p.innerHTML = str;
         mjsonrpc_call("db_rename", { "paths": [path], "new_names": [str]})
                 .then()
                 .catch(error => mjsonrpc_error_alert(error));
      }

      function search_key() {
         dlgAlert("Function not yet implemented");
      }

      // user clicks on subdirectory, so open it
      function subdir_open(path) {
         unselect_all_keys();

         // find key belonging to 'path'
         let dirs = path.split('/');
         let o = odb;
         for (let l=1 ; l<dirs.length ; l++) {
            for (let i = 0 ; i<o.key.length ; i++)
               if (o.key[i].name == dirs[l]) {
                  if (l == dirs.length-1)
                     o.key[i].subdir_open = !o.key[i].subdir_open;
                  else
                     o = o.key[i].value; // recurse one level
                  break;
               }
         }
         odb.skip_yellow = true;
         odb_update(odb);
      }

      // after a double click open the subdirectory as top level
      function subdir_goto(path) {
         unselect_all_keys();

         // kill old timer
         if (updateTimer !== undefined)
            window.clearTimeout(updateTimer);

         // update URL
         let url = window.location.href;
         if (url.search("&odb_path") !== -1)
            url = url.slice(0, url.search("&odb_path"));
         url += "&odb_path=" + path;
         if (url !== window.location.href)
            window.history.replaceState({}, "MIDAS ODB Browser", url);

         // initialize ODB object
         odb = { id: odb.id, path: path, level: 0, dataIndex: 0, key: [] };

         odb.skip_yellow = true;
         odb_update(odb);
      }

      let numClicks = 0;
      let singleClickTimer;
      function subdir_click(event, tr) {

         event.stopPropagation(); // don't pass event to not select row

         // travel from the <a> element up to the <tr> element which contains the path
         while (tr.tagName !== 'TR')
            tr = tr.parentElement;
         let path = tr.odbPath;

         numClicks++;
         if (numClicks === 1) {
            // if no second click in the next 200ms, we have a single click
            singleClickTimer = setTimeout(() => {
               numClicks = 0;
               subdir_open(path);
            }, 200);
         } else if (numClicks === 2) {
            // we have a double click
            clearTimeout(singleClickTimer);
            numClicks = 0;
            subdir_goto(path);
         }
      }

      // push all paths of open subdirectories recursively for a following db_ls
      function push_paths(paths, odb, path) {
         odb.dataIndex = paths.length;
         paths.push(path);
         for (let i=0 ; i< odb.key.length ; i++) {
            if (odb.key[i].type === TID_KEY && odb.key[i].subdir_open) {
               if (odb.key[i].value.id === undefined) {
                  odb.key[i].value = {
                     id: odb.id,
                     path: odb.path === '/' ? '/' + odb.key[i].name : odb.path + '/' + odb.key[i].name,
                     level: odb.level + 1,
                     dataIndex: paths.length,
                     key: []
                  };
               }
               push_paths(paths, odb.key[i].value, odb.key[i].value.path);
            }
         }
      }

      // update overall ODB display
      function odb_update(odb) {

         if (updateTimer !== undefined)
            window.clearTimeout(updateTimer);
         let d = document.getElementById(odb.id);
         let tb = d.firstChild.firstChild;
         let row = { i:4 };

         // show clickable ODB path in top row
         let dirs;
         if (odb.path === '/')
            dirs = ['/'];
         else
            dirs = odb.path.split('/');
         let path = '';
         let s = "<a href='#' onclick=\"subdir_goto('/');return false;\">/</a>&nbsp;";
         for (let i=1 ; i<dirs.length ; i++) {
            path += "/" + dirs[i];
            s += "<a href='#' onclick=\"subdir_goto('" + path + "');return false;\">"+dirs[i]+"</a>";
            if (i < dirs.length - 1)
               s += "&nbsp;/&nbsp;";
         }
         if (s != tb.childNodes[1].firstChild.innerHTML)
            tb.childNodes[1].firstChild.innerHTML = s;

         // request ODB data
         let paths = [];
         push_paths(paths, odb, odb.path);

         mjsonrpc_db_ls(paths).then(rpc => {
            odb_extract(odb, rpc.result.data);
            odb_print(tb, row, odb);
            odb.skip_yellow = false;

            // call timer in one second to update again
            updateTimer = window.setTimeout(odb_update, 1000, odb);
         }).catch(error => mjsonrpc_error_alert(error));
      }

      // extract keys and put them into odb tree from db_ls result in dataArray
      function odb_extract(odb, dataArray) {
         let data = dataArray[odb.dataIndex];
         let n = 0;
         for (const item in data) {
            if (item.indexOf('/') !== -1)
               continue;

            let key = {};
            key.name = item;
            key.value = data[item];
            if (typeof key.value === 'object' && Object.keys(key.value).length === 0) {
               key.type = TID_KEY;
               key.subdir_open = false;
               key.num_values = 1;
               key.item_size = 0;
               key.last_written = 0;
               key.access_mode = 0;
            } else {
               key.type = data[item + '/key'].type;
               key.link = data[item + '/key'].link;
               key.num_values = data[item + '/key'].num_values;
               if (key.num_values === undefined)
                  key.num_values = 1;
               if (data[item + '/key'].item_size !== undefined)
                  key.item_size = data[item + '/key'].item_size;
               else
                  key.item_size = tid_size[key.type];
               key.last_written = data[item + '/key'].last_written;
               key.access_mode = data[item + '/key'].access_mode;
            }

            if (odb.key.length <= n)
               odb.key.push(key);
            else {
               if (odb.key[n].subdir_open) {
                  key.subdir_open = true;
                  key.value = odb.key[n].value;
               }
               odb.key[n] = key;
            }
            n++;

            // if current key is a subdirectory, call us recursively
            if (key.type === TID_KEY && key.subdir_open) {
               odb_extract(odb.key[n-1].value, dataArray);
            }
         }

         // if local data remaining, ODB key must have been deleted, so delete also local data
         if (odb.key.length > n) {
            odb.key = odb.key.slice(0, n);
            odb.skip_yellow = true;
         }
      }

      function odb_print(tb, row, odb) {
         for (const key of odb.key) {
            // Print current key
            odb_print_key(tb, odb, row, odb.path, key);
            row.i++;

            // Print whole subdirectory if open
            if (key.type === TID_KEY && key.subdir_open) {

               // Propagate skip_yellow flag (dirctory just opened) to all subkeys
               key.value.skip_yellow = odb.skip_yellow;

               // Print whole subdirectory
               odb_print(tb, row, key.value);
            }
         }

         // At the end, remove old rows if subdirectory has been closed
         if (odb.level === 0)
            while (tb.childNodes.length > row.i)
               tb.removeChild(tb.childNodes[tb.childNodes.length-1]);
      }

      function find_input_element(e) {
         if (e === undefined)
            return false;
         for (const c of e.childNodes) {
            if (c.tagName === 'INPUT')
               return true;
            if (c.childNodes.length > 0)
               return find_input_element(c);
         }
      }

      function odb_print_key(tb, odb, row, path, key) {
         // console.log(row, key.name, key.value);

         // ful path to key
         let keyPath = (path === '/' ? '/' + key.name : path + '/' + key.name);

         // create empty row
         let tr = document.createElement('TR');

         // Handle column
         let td = document.createElement('TD');
         td.className = 'odbKey';
         td.setAttribute('name', 'odbHandle');
         td.style.display = odbHandle ? 'table-cell' : 'none';
         td.style.width = "10px";
         tr.appendChild(td);
         td.innerHTML = '<img src="icons/menu.svg">';

         // Key name
         td = document.createElement('TD');
         td.className = 'odbKey';
         tr.appendChild(td);

         // Add three spaces of indent for each level
         let indent = "";
         for (let i = 0; i < odb.level; i++)
            indent += "&nbsp;&nbsp;&nbsp;";

         // Print subdir with open subdir handler
         if (key.type === TID_KEY) {
            let handler = "onclick=\"subdir_click(event, this);return false;\" ";
            if (key.subdir_open)
               td.innerHTML = indent + "<a href='#' " +
                       handler +
                       "> \u25BE " + key.name + "</a>";
            else
               td.innerHTML = indent + "<a href='#' " +
                       handler +
                       "> \u25B8 " + key.name + "</a>";
         } else
            td.innerHTML = indent + key.name;

         // add link if present
         if (key.link !== undefined) {
            td.innerHTML += ' &rarr; <span>'+ '<a href="#" ' +
                    'onclick="inline_edit(this.parentNode, \'' +
                    key.link + '\', odb_setlink, undefined, \'' + keyPath +
                    '\'); return false;" ' +
                    ' title="Change value">' + key.link +
                    '</a></span>';
         }

         // Subdirs occupy all 8 columns
         if (key.type === TID_KEY) {
            td.colSpan = "8";

            if (tb.childNodes.length > row.i) {
               let selected = tb.childNodes[row.i].odbSelected;
               if (selected) {
                  tr.style.backgroundColor = '#004CBD';
                  change_color(tr, '#FFFFFF');
               }

               if (!tb.childNodes[row.i].isEqualNode(tr))
                  tb.childNodes[row.i].replaceWith(tr);
            } else
               tb.appendChild(tr);

            // Install mouse click handler
            tb.childNodes[row.i].addEventListener('click', select_key);

            // Remember ODB path in row
            tb.childNodes[row.i].odbPath = keyPath;

            return;
         }

         // Value
         td = document.createElement('TD');
         td.className = 'odbKey';
         tr.appendChild(td);

         if (Array.isArray(key.value)) {
            td.innerHTML =
                    '<div><a href="#" ' +
                    'onclick="inline_edit(this.parentNode, \'' +
                    key.value[0] + '\', odb_setall, 10, \''+ keyPath +
                    '\');return false;" ' +
                    'title="Set array elements to same value">*</a></div>';
         } else {
            let edit = '<a href="#" onclick="ODBInlineEdit(this.parentNode, \'' + keyPath + '\');return false;" ' +
                    'onfocus="ODBInlineEdit(this.parentNode, \'' + keyPath + '\')" title="Change value">';

            let v = key.value.toString();
            if (key.type === TID_STRING && v === "")
               v = "(empty)";
            else if (key.type === TID_LINK)
               v = '<span style="color:red;background-color:yellow">(cannot resolve link)</span>';
            else if (key.type === TID_BOOL)
               v = (key.value ? 'y' : 'n') + ' (' + (key.value ? '1' : '0') + ')';
            else if (v.substring(0, 2) === "0x")
               v += " (" + parseInt(key.value) + ')';
            else if (key.type !== TID_STRING && key.type !== TID_LINK && key.type !== TID_FLOAT && key.type !== TID_DOUBLE)
               v += " (0x" + key.value.toString(16).toUpperCase() + ')';
            td.innerHTML = edit + v + '</a>';
         }

         // Type
         td = document.createElement('TD');
         td.className = 'odbKey';
         td.setAttribute('name', 'odbExt');
         td.style.display = odbExpand ? 'table-cell' : 'none';
         tr.appendChild(td);
         td.appendChild(document.createTextNode(tid_name[key.type]));

         // #Val
         td = document.createElement('TD');
         td.className = 'odbKey';
         td.setAttribute('name', 'odbExt');
         td.style.display = odbExpand ? 'table-cell' : 'none';
         tr.appendChild(td);
         td.innerHTML = '<a href="#" onclick="resize_array(\''+keyPath+'\','+key.num_values+');return false;">'
                 + key.num_values + '</a>';

         // Size
         td = document.createElement('TD');
         td.className = 'odbKey';
         td.setAttribute('name', 'odbExt');
         td.style.display = odbExpand ? 'table-cell' : 'none';
         tr.appendChild(td);
         if (key.type === TID_STRING)
            td.innerHTML = '<a href="#" onclick="resize_string(\''+keyPath+'\','+key.item_size+','+key.num_values+');return false;">'
                    + key.item_size + '</a>';
         else
            td.innerHTML = key.item_size;

         // Written
         td = document.createElement('TD');
         td.className = 'odbKey';
         td.setAttribute('name', 'odbExt');
         td.style.display = odbExpand ? 'table-cell' : 'none';
         tr.appendChild(td);
         let s = Math.floor(0.5 + new Date().getTime() / 1000 - key.last_written);
         let t;
         if (s < 60)
            t = s + 's';
         else if (s < 60 * 60)
            t = Math.floor(0.5 + s / 60) + 'm';
         else if (s < 60 * 60 * 24)
            t = Math.floor(0.5 + s / 60 / 60) + 'h';
         else if (s < 60 * 60 * 24 * 99)
            t = Math.floor(0.5 + s / 60 / 60 / 24) + 'd';
         else
            t = ">99d";
         td.appendChild(document.createTextNode(t));

         // Mode
         td = document.createElement('TD');
         td.className = 'odbKey';
         td.setAttribute('name', 'odbExt');
         td.style.display = odbExpand ? 'table-cell' : 'none';
         tr.appendChild(td);
         let mode = key.access_mode;
         let m = "";
         if (mode & MODE_READ)
            m += "R";
         if (mode & MODE_WRITE)
            m += "W";
         if (mode & MODE_DELETE)
            m += "D";
         if (mode & MODE_EXCLUSIVE)
            m += "X";
         if (mode & MODE_WATCH)
            m += "W";
         td.appendChild(document.createTextNode(m));

         if (row.i >= tb.childNodes.length) {
            // append new row if nothing exists
            tb.appendChild(tr);
         } else {
            // replace current row if it differs
            if (!tb.childNodes[row.i].isEqualNode(tr)) {
               if (tb.childNodes[row.i].childNodes[1].colSpan !== 1)
                  tb.childNodes[row.i].childNodes[1].colSpan = "1";
               for (let i = 0; i < 8; i++) {
                  let yellowBg = false;

                  // check for data change in value column
                  if (i === 2) {
                     let oldElem = tb.childNodes[row.i].childNodes[i];
                     if (oldElem === undefined)
                        oldElem = "xxx";
                     else {
                        while (oldElem.tagName === 'TD' || oldElem.tagName === 'A' || oldElem.tagName === 'DIV')
                           oldElem = oldElem.childNodes[0]; // get into <td> <a> <div> elements
                        oldElem = oldElem.parentNode.innerHTML;
                     }
                     let newElem = tr.childNodes[i];
                     if (newElem === undefined)
                        newElem = "xxx";
                     else {
                        while (newElem.tagName === 'TD' || newElem.tagName === 'A' || newElem.tagName === 'DIV')
                           newElem = newElem.childNodes[0]; // get into <td> <a> <div> elements
                        newElem = newElem.parentNode.innerHTML;
                     }

                     if (oldElem !== newElem &&  // value changed
                             !odb.skip_yellow &&       // skip if globally disabled
                             // skip if edit just finished
                             !(oldElem.indexOf('(') == -1 && newElem.indexOf('(') !== -1) &&
                             // skip '*' of arrays
                             newElem.indexOf('>*</a>') === -1)
                        yellowBg = true;
                     else
                        yellowBg = false;
                  }

                  // check for edit mode
                  let inlineEdit = find_input_element(tb.childNodes[row.i].childNodes[i]);

                  if (tb.childNodes[row.i].childNodes[i] === undefined)
                     tb.childNodes[row.i].appendChild(tr.childNodes[i].cloneNode(true));
                  else if (!inlineEdit) {
                     let e = tb.childNodes[row.i].childNodes[i];

                     let c = e.style.color; // preserve color if key is slected
                     e.innerHTML = tr.childNodes[i].innerHTML;
                     change_color(e, c);

                     if (yellowBg) {
                        e.style.backgroundColor = 'var(--myellow)';
                        e.style.setProperty("-webkit-transition", "", "");
                        e.style.setProperty("transition", "", "");
                        e.age = new Date() / 1000;
                     }

                     if (e.age !== undefined && new Date() / 1000 > e.age + 1) {
                        e.style.setProperty("-webkit-transition", "background-color 1s", "");
                        e.style.setProperty("transition", "background-color 1s", "");
                        e.style.backgroundColor = "";
                     }
                  }
               }
            }
         }

         // Install mouse click handler
         tb.childNodes[row.i].addEventListener('click', select_key);

         // Remember ODB path in row
         tb.childNodes[row.i].odbPath = keyPath;

         // Print array values
         if (Array.isArray(key.value)) {
            for (let i=0 ; i<key.value.length ; i++) {
               row.i++;

               // return if in edit mode
               if (tb.childNodes[row.i] !== undefined &&
                       tb.childNodes[row.i].childNodes[2] !== undefined &&
                       tb.childNodes[row.i].childNodes[2].inEdit)
                  continue;

               // create empty row
               let tr = document.createElement('TR');

               // Handle column (empty for array values)
               let td = document.createElement('TD');
               td.className = 'odbKey';
               td.setAttribute('name', 'odbHandle');
               td.style.display = odbHandle ? 'table-cell' : 'none';
               td.style.width = "10px";
               tr.appendChild(td);

               // Key name
               td = document.createElement('TD');
               td.className = 'odbKey';
               tr.appendChild(td);

               // Key value
               td = document.createElement('TD');
               td.className = 'odbKey';
               tr.appendChild(td);
               let p = (path === '/' ? '/' + key.name : path + '/' + key.name);
               p += '['+i+']';
               let edit = '<a href="#" onclick="ODBInlineEdit(this.parentNode, \''+p+'\');return false;"  '+
                       'onfocus="ODBInlineEdit(this.parentNode, \''+p+'\')" title="Change array element">';

               let v = key.value[i].toString();
               if (key.type === TID_STRING && v === "")
                  v = "(empty)";
               else if (key.type === TID_BOOL)
                  v = (key.value[i] ? 'y' : 'n') + ' (' + (key.value[i] ? '1' : '0') +')';
               else if (v.substring(0, 2) === "0x")
                  v += " (" + parseInt(key.value[i]) + ')';
               else if (key.type !== TID_STRING && key.type !== TID_LINK && key.type !== TID_FLOAT && key.type !== TID_DOUBLE)
                  v += " (0x" + key.value[i].toString(16).toUpperCase() + ')';
               td.innerHTML = '['+i+'] '+ edit + v + '</a>';

               // Empty fill cells
               for (let i=0 ; i<5 ; i++) {
                  td = document.createElement('TD');
                  td.className = 'odbKey';
                  td.setAttribute('name', 'odbExt');
                  td.style.display = odbExpand ? 'table-cell' : 'none';
                  tr.appendChild(td);
               }

               if (row.i >= tb.childNodes.length) {
                  tb.appendChild(tr);
               } else {
                  if (!tb.childNodes[row.i].isEqualNode(tr)) {
                     if (tr.childNodes.length === 1) { // Subdir
                        tb.childNodes[row.i].replaceWith(tr);
                     } else if (tr.childNodes.length === 8) { // Key
                        if (tb.childNodes[row.i].childNodes[1].colSpan !== 1)
                           tb.childNodes[row.i].childNodes[1].colSpan = "1";
                        for (let i = 0; i < 8; i++) {
                           let changed = false;

                           let oldValue;
                           if (tb.childNodes[row.i].childNodes[i] !== undefined)
                              oldValue = tb.childNodes[row.i].childNodes[i].innerHTML;
                           let newValue = tr.childNodes[i].innerHTML;

                           if (oldValue !== undefined &&
                                   oldValue !== newValue &&  // value changed
                                   i === 2 &&                // we are in value column
                                   !odb.skip_yellow &&       // skip if globally disabled
                                   // skip if edit just finished
                                   !(oldValue.indexOf('(') == -1 && newValue.indexOf('(') !== -1) &&
                                   // skip '*' of arrays
                                   newValue.indexOf('>*</a>') === -1)
                              changed = true;

                           if (tb.childNodes[row.i].childNodes[i] === undefined)
                              tb.childNodes[row.i].appendChild(tr.childNodes[i].cloneNode(true));
                           else
                              tb.childNodes[row.i].childNodes[i].innerHTML = tr.childNodes[i].innerHTML;

                           let e = tb.childNodes[row.i].childNodes[i];
                           if (changed) {
                              e.style.backgroundColor = 'var(--myellow)';
                              e.style.setProperty("-webkit-transition", "", "");
                              e.style.setProperty("transition", "", "");
                              e.age = new Date() / 1000;
                           }

                           if (e.age !== undefined && new Date() / 1000 > e.age + 1) {
                              e.style.setProperty("-webkit-transition", "background-color 1s", "");
                              e.style.setProperty("transition", "background-color 1s", "");
                              e.style.backgroundColor = "";
                           }
                        }
                     }
                  }
               }
            }
         }
      }

      function resize_array(path, n) {
         dlgQuery("Enter size of array:", n, do_resize_array, path);
      }

      function do_resize_array(n, path) {
         mjsonrpc_db_resize([path],[parseInt(n)]).then(rpc => {
         }).catch(error => mjsonrpc_error_alert(error));
      }

      function resize_string(path, size, num_values) {
         dlgQuery("Enter new string size:", size, do_resize_string, { "path": path, "num_values": num_values });
      }

      function do_resize_string(size, p) {
         mjsonrpc_call("db_resize_string",
                 { "paths": [p.path],
                    "new_lengths": [parseInt(p.num_values)],
                    "new_string_lengths": [parseInt(size)]}).then(rpc => {
         }).catch(error => mjsonrpc_error_alert(error));
      }

   </script>
</head>

<body class="mcss" onload="mhttpd_init('ODB'); odb_init('odb')">

   <div id="mheader"></div>
   <div id="msidenav"></div>

   <div id="mmain">
      <div id="odb"></div>
   </div>

   <!-- Create key dialog -->
   <div id="dlgCreate" class="dlgFrame">
      <div class="dlgTitlebar">Create ODB entry</div>
      <div class="dlgPanel">
         <table class="dialogTable" style="border-spacing:10px;">
            <tr>
               <td style="text-align: right">Directory:</td>
               <td style="text-align: left" id="odbCreateDir"></td>
            </tr>
            <tr>
               <td style="text-align: right">Type:</td>
               <td style="text-align: left">
                  <select id="odbCreateType"
                          onchange="
                             document.getElementById('odbCreateStrLenTR').style.visibility =
                                (this.value==='12') ? 'visible' : 'hidden';
                          ">
                     <option selected value=7>Integer (32-bit)
                     <option value=9>Float (4 Bytes)
                     <option value=12>String
                     <option value=1>Byte
                     <option value=2>Signed Byte
                     <option value=3>Character (8-bit)
                     <option value=4>Word (16-bit)
                     <option value=5>Short Integer (16-bit)
                     <option value=6>Double Word (32-bit)
                     <option value=8>Boolean
                     <option value=10>Double Float (8 Bytes)
                  </select>
               </td>
            </tr>
            <tr>
               <td style="text-align: right">Name:</td>
               <td style="text-align: left"><input type=text size=20 maxlength=31 id="odbCreateName"></td>
            </tr>
            <tr>
               <td style="text-align: right">Array size:</td>
               <td style="text-align: left"><input type=text size=6 value=1 id="odbCreateSize"></td>
            </tr>
            <tr id="odbCreateStrLenTR" style="visibility: hidden">
               <td style="text-align: right">String length:</td>
               <td style="text-align: left"><input type=text size=6 value=32 id="odbCreateStrLen"></td>
            </tr>
         </table>
         <button class="dlgButton" onclick="if(do_new_key())dlgHide('dlgCreate');">Create</button>
         <button class="dlgButton" onclick="dlgHide('dlgCreate')">Cancel</button>
      </div>
   </div>

</body>
</html>
